/* tslint:disable */
/* eslint-disable */
/**
 * okauth
 * For authorization this spec uses scopes:   - admin. Read/write access to everything. Requires valid access_token and secure_okauth_admin=true KV   - self. Access permissions are method specific. Requires valid access_token  Other scopes are method specific
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    InlineObject4,
    InlineObject4FromJSON,
    InlineObject4ToJSON,
    InlineObject5,
    InlineObject5FromJSON,
    InlineObject5ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
} from '../models';

export interface UsersBlockRequest {
    domain: string;
    login: string;
}

export interface UsersCreateRequest {
    inlineObject4: InlineObject4;
}

export interface UsersDeleteRequest {
    domain: string;
    login: string;
}

export interface UsersGetRequest {
    domain: string;
    login: string;
}

export interface UsersGetAllRequest {
    domain: string;
    page?: number;
    limit?: number;
    blocked?: boolean;
}

export interface UsersUnblockRequest {
    domain: string;
    login: string;
}

export interface UsersUpdateRequest {
    login: string;
    inlineObject5?: InlineObject5;
}

/**
 *
 */
export class UsersApi extends runtime.BaseAPI {

    /**
     * block user. It will be hidden from user queries and only admin will be able to request it, will not be able to authenticate and all refresh tokens will be invalidated.  Protected users cannot be blocked.  Allowed scopes:   - admin
     */
    async usersBlockRaw(requestParameters: UsersBlockRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.domain === null || requestParameters.domain === undefined) {
            throw new runtime.RequiredError('domain','Required parameter requestParameters.domain was null or undefined when calling usersBlock.');
        }

        if (requestParameters.login === null || requestParameters.login === undefined) {
            throw new runtime.RequiredError('login','Required parameter requestParameters.login was null or undefined when calling usersBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["access_token"] = this.configuration.apiKey("access_token"); // AccessToken authentication
        } else if(localStorage.getItem("access_token")) {
            queryParameters["access_token"] = localStorage.getItem("access_token")
        }

        const response = await this.request({
            path: `/users/{domain}/{login}/block`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters.domain))).replace(`{${"login"}}`, encodeURIComponent(String(requestParameters.login))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * block user. It will be hidden from user queries and only admin will be able to request it, will not be able to authenticate and all refresh tokens will be invalidated.  Protected users cannot be blocked.  Allowed scopes:   - admin
     */
    async usersBlock(requestParameters: UsersBlockRequest): Promise<void> {
        await this.usersBlockRaw(requestParameters);
    }

    /**
     * create user in local domain.  Allowed scopes:   - admin
     */
    async usersCreateRaw(requestParameters: UsersCreateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.inlineObject4 === null || requestParameters.inlineObject4 === undefined) {
            throw new runtime.RequiredError('inlineObject4','Required parameter requestParameters.inlineObject4 was null or undefined when calling usersCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["access_token"] = this.configuration.apiKey("access_token"); // AccessToken authentication
        } else if(localStorage.getItem("access_token")) {
            queryParameters["access_token"] = localStorage.getItem("access_token")
        }

        const response = await this.request({
            path: `/users/_`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject4ToJSON(requestParameters.inlineObject4),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * create user in local domain.  Allowed scopes:   - admin
     */
    async usersCreate(requestParameters: UsersCreateRequest): Promise<void> {
        await this.usersCreateRaw(requestParameters);
    }

    /**
     * delete users. Protected user cannot be deleted.  Allowed scopes:   - admin
     */
    async usersDeleteRaw(requestParameters: UsersDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.domain === null || requestParameters.domain === undefined) {
            throw new runtime.RequiredError('domain','Required parameter requestParameters.domain was null or undefined when calling usersDelete.');
        }

        if (requestParameters.login === null || requestParameters.login === undefined) {
            throw new runtime.RequiredError('login','Required parameter requestParameters.login was null or undefined when calling usersDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["access_token"] = this.configuration.apiKey("access_token"); // AccessToken authentication
        } else if(localStorage.getItem("access_token")) {
            queryParameters["access_token"] = localStorage.getItem("access_token")
        }

        const response = await this.request({
            path: `/users/{domain}/{login}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters.domain))).replace(`{${"login"}}`, encodeURIComponent(String(requestParameters.login))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * delete users. Protected user cannot be deleted.  Allowed scopes:   - admin
     */
    async usersDelete(requestParameters: UsersDeleteRequest): Promise<void> {
        await this.usersDeleteRaw(requestParameters);
    }

    /**
     * get specific users.  Allowed scopes:   - admin   - self. Can request any user but without groups and KV. Groups and KVs (including secure ones) are returned only when requesting yourself
     */
    async usersGetRaw(requestParameters: UsersGetRequest): Promise<runtime.ApiResponse<InlineResponse2003>> {
        if (requestParameters.domain === null || requestParameters.domain === undefined) {
            throw new runtime.RequiredError('domain','Required parameter requestParameters.domain was null or undefined when calling usersGet.');
        }

        if (requestParameters.login === null || requestParameters.login === undefined) {
            throw new runtime.RequiredError('login','Required parameter requestParameters.login was null or undefined when calling usersGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["access_token"] = this.configuration.apiKey("access_token"); // AccessToken authentication
        } else if(localStorage.getItem("access_token")) {
            queryParameters["access_token"] = localStorage.getItem("access_token")
        }

        const response = await this.request({
            path: `/users/{domain}/{login}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters.domain))).replace(`{${"login"}}`, encodeURIComponent(String(requestParameters.login))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     * get specific users.  Allowed scopes:   - admin   - self. Can request any user but without groups and KV. Groups and KVs (including secure ones) are returned only when requesting yourself
     */
    async usersGet(requestParameters: UsersGetRequest): Promise<InlineResponse2003> {
        const response = await this.usersGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * get users.  Allowed scopes:   - admin
     */
    async usersGetAllRaw(requestParameters: UsersGetAllRequest): Promise<runtime.ApiResponse<InlineResponse2002>> {
        if (requestParameters.domain === null || requestParameters.domain === undefined) {
            throw new runtime.RequiredError('domain','Required parameter requestParameters.domain was null or undefined when calling usersGetAll.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.blocked !== undefined) {
            queryParameters['blocked'] = requestParameters.blocked;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["access_token"] = this.configuration.apiKey("access_token"); // AccessToken authentication
        } else if(localStorage.getItem("access_token")) {
            queryParameters["access_token"] = localStorage.getItem("access_token")
        }

        const response = await this.request({
            path: `/users/{domain}`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters.domain))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2002FromJSON(jsonValue));
    }

    /**
     * get users.  Allowed scopes:   - admin
     */
    async usersGetAll(requestParameters: UsersGetAllRequest): Promise<InlineResponse2002> {
        const response = await this.usersGetAllRaw(requestParameters);
        return await response.value();
    }

    /**
     * unblock user.  Allowed scopes:   - admin
     */
    async usersUnblockRaw(requestParameters: UsersUnblockRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.domain === null || requestParameters.domain === undefined) {
            throw new runtime.RequiredError('domain','Required parameter requestParameters.domain was null or undefined when calling usersUnblock.');
        }

        if (requestParameters.login === null || requestParameters.login === undefined) {
            throw new runtime.RequiredError('login','Required parameter requestParameters.login was null or undefined when calling usersUnblock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["access_token"] = this.configuration.apiKey("access_token"); // AccessToken authentication
        } else if(localStorage.getItem("access_token")) {
            queryParameters["access_token"] = localStorage.getItem("access_token")
        }

        const response = await this.request({
            path: `/users/{domain}/{login}/unblock`.replace(`{${"domain"}}`, encodeURIComponent(String(requestParameters.domain))).replace(`{${"login"}}`, encodeURIComponent(String(requestParameters.login))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * unblock user.  Allowed scopes:   - admin
     */
    async usersUnblock(requestParameters: UsersUnblockRequest): Promise<void> {
        await this.usersUnblockRaw(requestParameters);
    }

    /**
     * change user in local domain.  Allowed scopes:   - admin   - self. User can only modify itself
     */
    async usersUpdateRaw(requestParameters: UsersUpdateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.login === null || requestParameters.login === undefined) {
            throw new runtime.RequiredError('login','Required parameter requestParameters.login was null or undefined when calling usersUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["access_token"] = this.configuration.apiKey("access_token"); // AccessToken authentication
        } else if(localStorage.getItem("access_token")){
            queryParameters["access_token"] = localStorage.getItem("access_token")
        }

        const response = await this.request({
            path: `/users/_/{login}`.replace(`{${"login"}}`, encodeURIComponent(String(requestParameters.login))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject5ToJSON(requestParameters.inlineObject5),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * change user in local domain.  Allowed scopes:   - admin   - self. User can only modify itself
     */
    async usersUpdate(requestParameters: UsersUpdateRequest): Promise<void> {
        await this.usersUpdateRaw(requestParameters);
    }

}
